// routes/_middleware.dart
//
// ignore_for_file: avoid_slow_async_io, avoid_catches_without_on_clauses

import 'dart:convert';
import 'dart:io';

import 'package:dart_frog/dart_frog.dart';
// import 'package:ht_api/src/middlewares/authentication_middleware.dart';
import 'package:ht_api/src/middlewares/error_handler.dart';
import 'package:ht_api/src/registry/model_registry.dart';
import 'package:ht_api/src/services/auth_service.dart';
import 'package:ht_api/src/services/auth_token_service.dart';
// Import the new JWT service
import 'package:ht_api/src/services/jwt_auth_token_service.dart';
import 'package:ht_api/src/services/verification_code_storage_service.dart';
import 'package:ht_app_settings_inmemory/ht_app_settings_inmemory.dart';
import 'package:ht_app_settings_repository/ht_app_settings_repository.dart';
import 'package:ht_data_inmemory/ht_data_inmemory.dart';
import 'package:ht_data_repository/ht_data_repository.dart';
import 'package:ht_email_inmemory/ht_email_inmemory.dart';
import 'package:ht_email_repository/ht_email_repository.dart';
import 'package:ht_shared/ht_shared.dart';
import 'package:uuid/uuid.dart'; // Import the uuid package

// --- Request ID Wrapper ---

/// {@template request_id}
/// A wrapper class holding a unique identifier (UUID v4) generated for each
/// incoming HTTP request.
///
/// **Purpose:**
/// The primary role of this ID is **traceability for logging and debugging**.
/// It allows developers to follow the entire lifecycle of a *single request*
/// through various middleware, route handlers, repository calls, and potential
/// external service interactions by searching logs for this specific ID.
/// If an error occurs during a request, this ID provides a way to isolate all
/// related log entries for that specific transaction, simplifying debugging.
///
/// **Scope:**
/// - The ID is **transient** for the request itself; it exists only during the
///   request-response cycle.
/// - It is **not persisted** in the main application database alongside models
///   like Headlines or Categories.
/// - Its value lies in being included in **persistent logs**.
///
/// **Distinction from other IDs:**
/// - **User ID:** Identifies the authenticated user making the request. Often
///   logged alongside the `request_id` for user-specific debugging.
/// - **Session ID:** Tracks a user's session across multiple requests.
/// - **Correlation ID:** Often generated by the *client* and passed in headers
///   to link related requests initiated by the client for a larger workflow.
///
/// **Implementation:**
/// This class ensures type safety when providing and reading the request ID
/// from the Dart Frog context using `context.provide<RequestId>` and
/// `context.read<RequestId>()`. This prevents potential ambiguity if other raw
/// strings were provided into the context.
/// {@endtemplate}
class RequestId {
  /// {@macro request_id}
  const RequestId(this.id);

  /// The unique identifier string (UUID v4).
  final String id;
}

// --- Helper Function to Load Fixtures ---
// Note:
// Error handling here is basic. In a real app,
// consider more robust file checks.
// ignore: unused_element
Future<List<Map<String, dynamic>>> _loadFixture(String fileName) async {
  final path = 'lib/src/fixtures/$fileName';
  try {
    final file = File(path);
    if (!await file.exists()) {
      print('Warning: Fixture file not found at $path. Returning empty list.');
      return [];
    }
    final content = await file.readAsString();
    final decoded = jsonDecode(content) as List<dynamic>?; // Allow null
    // Ensure items are maps
    return decoded?.whereType<Map<String, dynamic>>().toList() ?? [];
  } catch (e) {
    print('Error loading or parsing fixture file $path: $e');
    return []; // Return empty on error to avoid crashing startup
  }
}

// --- Repository Creation Logic ---
// Synchronous fixture loader (use with caution)
List<Map<String, dynamic>> _loadFixtureSync(String fileName) {
  final path = 'lib/src/fixtures/$fileName';
  try {
    final file = File(path);
    if (!file.existsSync()) {
      print('Warning: Fixture file not found at $path. Returning empty list.');
      return [];
    }
    final content = file.readAsStringSync();
    final decoded = jsonDecode(content) as List<dynamic>?;
    return decoded?.whereType<Map<String, dynamic>>().toList() ?? [];
  } catch (e) {
    print('Error loading or parsing fixture file $path: $e');
    return [];
  }
}

HtDataRepository<Headline> _createHeadlineRepository() {
  print('Initializing Headline Repository...');
  final initialData =
      _loadFixtureSync('headlines.json').map(Headline.fromJson).toList();
  final client = HtDataInMemoryClient<Headline>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Headline Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Headline>(dataClient: client);
}

HtDataRepository<Category> _createCategoryRepository() {
  print('Initializing Category Repository...');
  final initialData =
      _loadFixtureSync('categories.json').map(Category.fromJson).toList();
  final client = HtDataInMemoryClient<Category>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Category Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Category>(dataClient: client);
}

HtDataRepository<Source> _createSourceRepository() {
  print('Initializing Source Repository...');
  final initialData =
      _loadFixtureSync('sources.json').map(Source.fromJson).toList();
  final client = HtDataInMemoryClient<Source>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Source Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Source>(dataClient: client);
}

HtDataRepository<Country> _createCountryRepository() {
  print('Initializing Country Repository...');
  final initialData =
      _loadFixtureSync('countries.json').map(Country.fromJson).toList();
  final client = HtDataInMemoryClient<Country>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Country Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Country>(dataClient: client);
}

// --- Middleware Definition ---
Handler middleware(Handler handler) {
  // Initialize repositories when middleware is first created
  // This ensures they are singletons for the server instance.
  final headlineRepository = _createHeadlineRepository();
  final categoryRepository = _createCategoryRepository();
  final sourceRepository = _createSourceRepository();
  final countryRepository = _createCountryRepository();
  final settingsClient = HtAppSettingsInMemory(); // Using in-memory for now
  final settingsRepository = HtAppSettingsRepository(client: settingsClient);
  const uuid = Uuid();

  // --- Auth Dependencies ---
  // User Repo (using InMemory for now)
  final userRepository = HtDataRepository<User>(
    dataClient: HtDataInMemoryClient<User>(
      toJson: (u) => u.toJson(),
      getId: (u) => u.id,
      // No initial user data fixture needed for auth flow typically
    ),
  );
  // Email Repo (using InMemory)
  const emailRepository = HtEmailRepository(
    emailClient: HtEmailInMemoryClient(),
  );
  // Auth Services (using JWT and in-memory implementations)
  // Instantiate the new JWT service, passing its dependencies
  final authTokenService = JwtAuthTokenService(
    userRepository: userRepository,
    uuidGenerator: uuid,
  );
  final verificationCodeStorageService =
      InMemoryVerificationCodeStorageService();
  final authService = AuthService(
    userRepository: userRepository,
    authTokenService: authTokenService,
    verificationCodeStorageService: verificationCodeStorageService,
    emailRepository: emailRepository,
    uuidGenerator: uuid,
  );

  // Chain the providers and other middleware
  return handler
      // --- Request ID Provider ---
      // Generate a unique ID for each request and provide it via context.
      // Using the RequestId wrapper ensures type safety for context reads.
      .use((innerHandler) {
        return (context) {
          final requestIdValue = uuid.v4();
          final requestId = RequestId(requestIdValue);
          // Provide the RequestId instance to downstream handlers/middleware
          return innerHandler(context.provide<RequestId>(() => requestId));
        };
      })
      // Provide the Model Registry Map
      .use(
        modelRegistryProvider,
      ) // Uses the provider defined in model_registry.dart

      // Provide each specific repository instance
      .use(provider<HtDataRepository<Headline>>((_) => headlineRepository))
      .use(provider<HtDataRepository<Category>>((_) => categoryRepository))
      .use(provider<HtDataRepository<Source>>((_) => sourceRepository))
      .use(provider<HtDataRepository<Country>>((_) => countryRepository))
      .use(provider<HtAppSettingsRepository>((_) => settingsRepository))
      // --- Provide Auth Dependencies ---
      .use(provider<HtDataRepository<User>>((_) => userRepository))
      .use(provider<HtEmailRepository>((_) => emailRepository))
      .use(provider<AuthTokenService>((_) => authTokenService))
      .use(
        provider<VerificationCodeStorageService>(
          (_) => verificationCodeStorageService,
        ),
      )
      .use(provider<AuthService>((_) => authService))
      // --- Provide UUID ---
      .use(provider<Uuid>((_) => uuid)) // Provide Uuid instance

      // --- Core Middleware ---
      .use(requestLogger()) // Basic request logging
      // Apply authenticationProvider to make User? available downstream
      // .use(authenticationProvider())
      // Error handler should generally be last to catch all upstream errors
      .use(errorHandler());
}
