import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:dart_frog/dart_frog.dart';
import 'package:ht_api/src/middlewares/error_handler.dart';
import 'package:ht_api/src/rbac/permission_service.dart'; // Import PermissionService
import 'package:ht_api/src/registry/model_registry.dart';
import 'package:ht_api/src/services/auth_service.dart';
import 'package:ht_api/src/services/auth_token_service.dart';
import 'package:ht_api/src/services/default_user_preference_limit_service.dart'; // Import DefaultUserPreferenceLimitService
import 'package:ht_api/src/services/jwt_auth_token_service.dart';
import 'package:ht_api/src/services/token_blacklist_service.dart';
import 'package:ht_api/src/services/user_preference_limit_service.dart'; // Import UserPreferenceLimitService interface
import 'package:ht_api/src/services/verification_code_storage_service.dart';
import 'package:ht_data_inmemory/ht_data_inmemory.dart';
import 'package:ht_data_repository/ht_data_repository.dart';
import 'package:ht_email_inmemory/ht_email_inmemory.dart';
import 'package:ht_email_repository/ht_email_repository.dart';
import 'package:ht_shared/ht_shared.dart';
import 'package:uuid/uuid.dart';

// Assuming a fixed ID for the AppConfig document
const String _appConfigId = 'app_config';

// --- Request ID Wrapper ---

/// {@template request_id}
/// A wrapper class holding a unique identifier (UUID v4) generated for each
/// incoming HTTP request.
///
/// **Purpose:**
/// The primary role of this ID is **traceability for logging and debugging**.
/// It allows developers to follow the entire lifecycle of a *single request*
/// through various middleware, route handlers, repository calls, and potential
/// external service interactions by searching logs for this specific ID.
/// If an error occurs during a request, this ID provides a way to isolate all
/// related log entries for that specific transaction, simplifying debugging.
///
/// **Scope:**
/// - The ID is **transient** for the request itself; it exists only during the
///   request-response cycle.
/// - It is **not persisted** in the main application database alongside models
///   like Headlines or Categories.
/// - Its value lies in being included in **persistent logs**.
///
/// **Distinction from other IDs:**
/// - **User ID:** Identifies the authenticated user making the request. Often
///   logged alongside the `request_id` for user-specific debugging.
/// - **Session ID:** Tracks a user's session across multiple requests.
/// - **Correlation ID:** Often generated by the *client* and passed in headers
///   to link related requests initiated by the client for a larger workflow.
///
/// **Implementation:**
/// This class ensures type safety when providing and reading the request ID
/// from the Dart Frog context using `context.provide<RequestId>` and
/// `context.read<RequestId>()`. This prevents potential ambiguity if other raw
/// strings were provided into the context.
/// {@endtemplate}
class RequestId {
  /// {@macro request_id}
  const RequestId(this.id);

  /// The unique identifier string (UUID v4).
  final String id;
}

// --- Helper Function to Load Fixtures ---
// Note:
// Error handling here is basic, consider more robust file checks.
// ignore: unused_element
Future<List<Map<String, dynamic>>> _loadFixture(String fileName) async {
  final path = 'lib/src/fixtures/$fileName';
  try {
    final file = File(path);
    if (!file.existsSync()) {
      print('Warning: Fixture file not found at $path. Returning empty list.');
      return [];
    }
    final content = await file.readAsString();
    final decoded = jsonDecode(content) as List<dynamic>?; // Allow null
    // Ensure items are maps
    return decoded?.whereType<Map<String, dynamic>>().toList() ?? [];
  } catch (e) {
    print('Error loading or parsing fixture file $path: $e');
    return []; // Return empty on error to avoid crashing startup
  }
}

// --- Repository Creation Logic ---
// Synchronous fixture loader (use with caution)
List<Map<String, dynamic>> _loadFixtureSync(String fileName) {
  final path = 'lib/src/fixtures/$fileName';
  try {
    final file = File(path);
    if (!file.existsSync()) {
      print('Warning: Fixture file not found at $path. Returning empty list.');
      return [];
    }
    final content = file.readAsStringSync();
    final decoded = jsonDecode(content);

    if (decoded is Map<String, dynamic>) {
      // If it's a single object, wrap it in a list
      return [decoded];
    } else if (decoded is List<dynamic>) {
      // If it's a list, filter for maps and return
      return decoded.whereType<Map<String, dynamic>>().toList();
    } else {
      print('Error: Fixture file $path contains unexpected JSON type.');
      return [];
    }
  } catch (e) {
    print('Error loading or parsing fixture file $path: $e');
    return [];
  }
}

HtDataRepository<Headline> _createHeadlineRepository() {
  print('Initializing Headline Repository...');
  final initialData =
      _loadFixtureSync('headlines.json').map(Headline.fromJson).toList();
  final client = HtDataInMemoryClient<Headline>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Headline Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Headline>(dataClient: client);
}

HtDataRepository<Category> _createCategoryRepository() {
  print('Initializing Category Repository...');
  final initialData =
      _loadFixtureSync('categories.json').map(Category.fromJson).toList();
  final client = HtDataInMemoryClient<Category>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Category Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Category>(dataClient: client);
}

HtDataRepository<Source> _createSourceRepository() {
  print('Initializing Source Repository...');
  final initialData =
      _loadFixtureSync('sources.json').map(Source.fromJson).toList();
  final client = HtDataInMemoryClient<Source>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Source Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Source>(dataClient: client);
}

HtDataRepository<Country> _createCountryRepository() {
  print('Initializing Country Repository...');
  final initialData =
      _loadFixtureSync('countries.json').map(Country.fromJson).toList();
  final client = HtDataInMemoryClient<Country>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Country Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Country>(dataClient: client);
}

// New repositories for user settings and preferences
HtDataRepository<UserAppSettings> _createUserAppSettingsRepository() {
  print('Initializing UserAppSettings Repository...');
  final client = HtDataInMemoryClient<UserAppSettings>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    // User settings are created on demand, no initial fixture needed
  );
  print('UserAppSettings Repository Initialized.');
  return HtDataRepository<UserAppSettings>(dataClient: client);
}

HtDataRepository<UserContentPreferences>
    _createUserContentPreferencesRepository() {
  print('Initializing UserContentPreferences Repository...');
  final client = HtDataInMemoryClient<UserContentPreferences>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    // User preferences are created on demand, no initial fixture needed
  );
  print('UserContentPreferences Repository Initialized.');
  return HtDataRepository<UserContentPreferences>(dataClient: client);
}

HtDataRepository<AppConfig> _createAppConfigRepository() {
  print('Initializing AppConfig Repository...');
  final fixtureData = _loadFixtureSync('app_config.json');
  if (fixtureData.isEmpty) {
    throw Exception('Failed to load app_config.json fixture or it is empty.');
  }
  final initialData = [
    AppConfig.fromJson(fixtureData.first),
  ]; // Assuming one config
  final client = HtDataInMemoryClient<AppConfig>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('AppConfig Repository Initialized.');
  return HtDataRepository<AppConfig>(dataClient: client);
}

/// Middleware to asynchronously load and provide the AppConfig.
Middleware _appConfigProviderMiddleware() {
  return (handler) {
    return (context) async {
      // Read the AppConfigRepository from the context
      final appConfigRepository = context.read<HtDataRepository<AppConfig>>();
      // Read the AppConfig instance
      final appConfig = await appConfigRepository.read(id: _appConfigId);
      // Provide the AppConfig instance to downstream handlers/middleware
      return handler(context.provide<AppConfig>(() => appConfig));
    };
  };
}

// --- Middleware Definition ---
Handler middleware(Handler handler) {
  // Initialize repositories when middleware is first created
  // This ensures they are singletons for the server instance.
  final headlineRepository = _createHeadlineRepository();
  final categoryRepository = _createCategoryRepository();
  final sourceRepository = _createSourceRepository();
  final countryRepository = _createCountryRepository();
  final userSettingsRepository = _createUserAppSettingsRepository(); // New
  final userContentPreferencesRepository =
      _createUserContentPreferencesRepository();
  final appConfigRepository = _createAppConfigRepository();

  const uuid = Uuid();

  // --- Auth Dependencies ---
  // User Repo (using InMemory for now)
  final userRepository = HtDataRepository<User>(
    dataClient: HtDataInMemoryClient<User>(
      toJson: (u) => u.toJson(),
      getId: (u) => u.id,
      // No initial user data fixture needed for auth flow typically
    ),
  );
  print('[MiddlewareSetup] HtDataRepository<User> instantiated.');
  // Email Repo (using InMemory)
  const emailRepository = HtEmailRepository(
    emailClient: HtEmailInMemoryClient(),
  );
  print('[MiddlewareSetup] HtEmailRepository instantiated.');
  // Auth Services (using JWT and in-memory implementations)
  final tokenBlacklistService = InMemoryTokenBlacklistService();
  print('[MiddlewareSetup] InMemoryTokenBlacklistService instantiated.');
  // Instantiate the JWT service, passing its dependencies
  final authTokenService = JwtAuthTokenService(
    userRepository: userRepository,
    blacklistService: tokenBlacklistService,
    uuidGenerator: uuid,
  );
  print('[MiddlewareSetup] JwtAuthTokenService instantiated.');
  final verificationCodeStorageService =
      InMemoryVerificationCodeStorageService();
  print(
    '[MiddlewareSetup] InMemoryVerificationCodeStorageService instantiated.',
  );
  final authService = AuthService(
    userRepository: userRepository,
    authTokenService: authTokenService,
    verificationCodeStorageService: verificationCodeStorageService,
    emailRepository: emailRepository,
    userAppSettingsRepository: userSettingsRepository,
    userContentPreferencesRepository: userContentPreferencesRepository,
    uuidGenerator: uuid,
  );
  print('[MiddlewareSetup] AuthService instantiated.');

  // --- RBAC Dependencies ---
  const permissionService = PermissionService();

  // --- User Preference Limit Service ---
  final userPreferenceLimitService = DefaultUserPreferenceLimitService(
    appConfigRepository: appConfigRepository,
  );
  print('[MiddlewareSetup] DefaultUserPreferenceLimitService instantiated.');

  // ==========================================================================
  // IMPORTANT: The order of middleware matters significantly!
  // Middleware is applied in layers (like an onion). A request flows "in"
  // through the chain, hits the route handler, and the response flows "out".
  // Providers must be added *before* the middleware/handlers that read them.
  // Error handlers should typically be placed late in the "request" phase
  // (or early in the "response" phase) to catch errors from upstream.
  // ==========================================================================
  return handler
      // Add the asynchronous AppConfig provider middleware here
      .use(_appConfigProviderMiddleware())
      // --- 1. Request ID Provider (Early Setup) ---
      // PURPOSE: Generates a unique ID (UUID v4) for each incoming request.
      //          Provides `RequestId` instance via context.
      // ORDER:   Placed *very early* so the ID is available for logging and
      //          tracing throughout the entire request lifecycle in all
      //          subsequent middleware and handlers.
      .use((innerHandler) {
        return (context) {
          final requestIdValue = uuid.v4();
          final requestId = RequestId(requestIdValue);
          // Provide the RequestId instance to downstream handlers/middleware
          return innerHandler(context.provide<RequestId>(() => requestId));
        };
      })

      // --- 2. Model Registry Provider (Early Setup) ---
      // PURPOSE: Provides the `ModelRegistry` map for dynamic JSON
      //          serialization/deserialization lookups.
      // ORDER:   Needed by some repository clients or handlers dealing with
      //          generic data types. Placed early, after RequestId.
      .use(modelRegistryProvider)

      // --- 3. Repository Providers (Core Data Access) ---
      // PURPOSE: Provide singleton instances of all data repositories.
      // ORDER:   These MUST be provided BEFORE any middleware or route handlers
      //          that need to interact with data (e.g., AuthService,
      //          authenticationProvider indirectly via AuthService/TokenService,
      //          specific route logic).
      .use(provider<HtDataRepository<Headline>>((_) => headlineRepository))
      .use(provider<HtDataRepository<Category>>((_) => categoryRepository))
      .use(provider<HtDataRepository<Source>>((_) => sourceRepository))
      .use(provider<HtDataRepository<Country>>((_) => countryRepository))
      .use(
        provider<HtDataRepository<User>>(
          (_) => userRepository,
        ),
      ) // Used by Auth services
      .use(
        provider<HtEmailRepository>(
          (_) => emailRepository,
        ),
      ) // Used by AuthService
      // New Repositories for User Settings and Preferences
      .use(
        provider<HtDataRepository<UserAppSettings>>(
          (_) => userSettingsRepository,
        ),
      )
      .use(
        provider<HtDataRepository<UserContentPreferences>>(
          (_) => userContentPreferencesRepository,
        ),
      )
      .use(
        provider<HtDataRepository<AppConfig>>(
          (_) => appConfigRepository,
        ),
      )
      // ORDER:   These MUST be provided BEFORE `authenticationProvider` and
      //          any route handlers that perform authentication/authorization.
      //          - `Uuid` is used by `AuthService` and `JwtAuthTokenService`.
      //          - `AuthTokenService` is read by `authenticationProvider`.
      //          - `AuthService` uses several repositories and `AuthTokenService`.
      //          - `VerificationCodeStorageService` is used by `AuthService`.
      //          - `TokenBlacklistService` is used by `JwtAuthTokenService`.
      .use(provider<Uuid>((_) => uuid)) // Read by AuthService & TokenService
      .use(
        provider<TokenBlacklistService>(
          (_) => tokenBlacklistService,
        ),
      ) // Read by AuthTokenService
      .use(
        provider<AuthTokenService>(
          (_) => authTokenService,
        ),
      ) // Read by AuthService
      .use(
        provider<VerificationCodeStorageService>(
          (_) => verificationCodeStorageService,
        ),
      ) // Read by AuthService
      .use(
        provider<AuthService>(
          (_) => authService,
        ),
      ) // Reads other services/repos

      // --- 5. RBAC Service Provider ---
      // PURPOSE: Provides the PermissionService for authorization checks.
      // ORDER:   Must be provided before any middleware or handlers that use it
      //          (e.g., authorizationMiddleware).
      .use(provider<PermissionService>((_) => permissionService))

      // --- 6. User Preference Limit Service Provider --- // New
      // PURPOSE: Provides the service for enforcing user preference limits.
      // ORDER:   Must be provided before any handlers that use it (specifically
      //          the generic data route handlers for UserContentPreferences).
      .use(
        provider<UserPreferenceLimitService>(
          (_) => userPreferenceLimitService,
        ),
      )

      // --- 7. Request Logger (Logging) ---
      // PURPOSE: Logs details about the incoming request and outgoing response.
      // ORDER:   Often placed late in the request phase / early in the response
      //          phase. Placing it here logs the request *before* the handler
      //          runs and the response *after* the handler (and error handler)
      //          completes. Can access `RequestId` and potentially `User?`.
      .use(requestLogger())

      // --- 8. Error Handler (Catch-All) ---
      // PURPOSE: Catches exceptions thrown by upstream middleware or route
      //          handlers and converts them into standardized JSON error responses.
      // ORDER:   MUST be placed *late* in the chain (typically last before the
      //          actual handler is invoked by the framework, or first in the
      //          response processing flow) so it can catch errors from
      //          everything that came before it (providers, auth middleware,
      //          route handlers). If placed too early, it won't catch errors
      //          from middleware/handlers defined after it.
      .use(errorHandler());
}
