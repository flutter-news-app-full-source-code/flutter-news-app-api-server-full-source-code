import 'package:dart_frog/dart_frog.dart';
import 'package:ht_api/src/config/database_connection.dart';
import 'package:ht_api/src/middlewares/error_handler.dart';
import 'package:ht_api/src/rbac/permission_service.dart';
import 'package:ht_api/src/services/auth_service.dart';
import 'package:ht_api/src/services/auth_token_service.dart';
import 'package:ht_api/src/services/dashboard_summary_service.dart';
import 'package:ht_api/src/services/database_seeding_service.dart';
import 'package:ht_api/src/services/default_user_preference_limit_service.dart';
import 'package:ht_api/src/services/jwt_auth_token_service.dart';
import 'package:ht_api/src/services/token_blacklist_service.dart';
import 'package:ht_api/src/services/user_preference_limit_service.dart';
import 'package:ht_api/src/services/verification_code_storage_service.dart';
import 'package:ht_data_client/ht_data_client.dart';
import 'package:ht_data_postgres/ht_data_postgres.dart';
import 'package:ht_data_repository/ht_data_repository.dart';
import 'package:ht_email_inmemory/ht_email_inmemory.dart';
import 'package:ht_email_repository/ht_email_repository.dart';
import 'package:ht_shared/ht_shared.dart';
import 'package:logging/logging.dart';
import 'package:postgres/postgres.dart';
import 'package:uuid/uuid.dart';

// --- Request ID Wrapper ---

/// {@template request_id}
/// A wrapper class holding a unique identifier (UUID v4) generated for each
/// incoming HTTP request.
///
/// **Purpose:**
/// The primary role of this ID is **traceability for logging and debugging**.
/// It allows developers to follow the entire lifecycle of a *single request*
/// through various middleware, route handlers, repository calls, and potential
/// external service interactions by searching logs for this specific ID.
/// If an error occurs during a request, this ID provides a way to isolate all
/// related log entries for that specific transaction, simplifying debugging.
///
/// **Scope:**
/// - The ID is **transient** for the request itself; it exists only during the
///   request-response cycle.
/// - It is **not persisted** in the main application database alongside models
///   like Headlines or Categories.
/// - Its value lies in being included in **persistent logs**.
///
/// **Distinction from other IDs:**
/// - **User ID:** Identifies the authenticated user making the request. Often
///   logged alongside the `request_id` for user-specific debugging.
/// - **Session ID:** Tracks a user's session across multiple requests.
/// - **Correlation ID:** Often generated by the *client* and passed in headers
///   to link related requests initiated by the client for a larger workflow.
///
/// **Implementation:**
/// This class ensures type safety when providing and reading the request ID
/// from the Dart Frog context using `context.provide<RequestId>` and
/// `context.read<RequestId>()`. This prevents potential ambiguity if other raw
/// strings were provided into the context.
/// {@endtemplate}
class RequestId {
  /// {@macro request_id}
  const RequestId(this.id);

  /// The unique identifier string (UUID v4).
  final String id;
}

// --- Middleware Definition ---
final _log = Logger('RootMiddleware');

/// Creates a data repository for a given type [T].
HtDataRepository<T> _createRepository<T>({
  required Connection connection,
  required String tableName,
  required FromJson<T> fromJson,
  required ToJson<T> toJson,
}) {
  return HtDataRepository<T>(
    dataClient: HtDataPostgresClient<T>(
      connection: connection,
      tableName: tableName,
      fromJson: fromJson,
      toJson: toJson,
      log: _log,
    ),
  );
}

Handler middleware(Handler handler) {
  // This is the root middleware for the entire API. It's responsible for
  // providing all shared dependencies to the request context.
  // The order of `.use()` calls is important: the last one in the chain
  // runs first.
  return handler
      // --- Core Middleware ---
      // These run after all dependencies have been provided.
      .use(errorHandler())
      .use(requestLogger())
      // --- Request ID Provider ---
      // This middleware provides a unique ID for each request for tracing.
      // It depends on the Uuid provider, so it must come after it.
      .use((innerHandler) {
        return (context) {
          _log.info('[REQ_LIFECYCLE] Request received. Generating RequestId...');
          final uuid = context.read<Uuid>();
          final requestId = RequestId(uuid.v4());
          _log.info('[REQ_LIFECYCLE] RequestId generated: ${requestId.id}');
          return innerHandler(context.provide<RequestId>(() => requestId));
        };
      })
      // --- Dependency Provider ---
      // This is the outermost middleware. It runs once per request, before any
      // other middleware. It's responsible for initializing and providing all
      // dependencies for the request.
      .use((handler) {
    return (context) async {
      // 1. Ensure the database connection is initialized.
      await DatabaseConnectionManager.instance.init();
      final connection = await DatabaseConnectionManager.instance.connection;

      // 2. Run database seeding (idempotent).
      final seedingService = DatabaseSeedingService(
        connection: connection,
        log: _log,
      );
      await seedingService.createTables();
      await seedingService.seedGlobalFixtureData();
      await seedingService.seedInitialAdminAndConfig();

      // 3. Initialize Repositories.
      final headlineRepository = _createRepository<Headline>(
        connection: connection,
        tableName: 'headlines',
        fromJson: Headline.fromJson,
        toJson: (h) => h.toJson(),
      );
      final categoryRepository = _createRepository<Category>(
        connection: connection,
        tableName: 'categories',
        fromJson: Category.fromJson,
        toJson: (c) => c.toJson(),
      );
      final sourceRepository = _createRepository<Source>(
        connection: connection,
        tableName: 'sources',
        fromJson: Source.fromJson,
        toJson: (s) => s.toJson(),
      );
      final countryRepository = _createRepository<Country>(
        connection: connection,
        tableName: 'countries',
        fromJson: Country.fromJson,
        toJson: (c) => c.toJson(),
      );
      final userRepository = _createRepository<User>(
        connection: connection,
        tableName: 'users',
        fromJson: User.fromJson,
        toJson: (u) => u.toJson(),
      );
      final userAppSettingsRepository = _createRepository<UserAppSettings>(
        connection: connection,
        tableName: 'user_app_settings',
        fromJson: UserAppSettings.fromJson,
        toJson: (s) => s.toJson(),
      );
      final userContentPreferencesRepository =
          _createRepository<UserContentPreferences>(
        connection: connection,
        tableName: 'user_content_preferences',
        fromJson: UserContentPreferences.fromJson,
        toJson: (p) => p.toJson(),
      );
      final appConfigRepository = _createRepository<AppConfig>(
        connection: connection,
        tableName: 'app_config',
        fromJson: AppConfig.fromJson,
        toJson: (c) => c.toJson(),
      );

      // 4. Initialize Services.
      const emailRepository = HtEmailRepository(
        emailClient: HtEmailInMemoryClient(),
      );
      final tokenBlacklistService = InMemoryTokenBlacklistService();
      final AuthTokenService authTokenService = JwtAuthTokenService(
        userRepository: userRepository,
        blacklistService: tokenBlacklistService,
        uuidGenerator: const Uuid(),
      );
      final verificationCodeStorageService =
          InMemoryVerificationCodeStorageService();
      final authService = AuthService(
        userRepository: userRepository,
        authTokenService: authTokenService,
        verificationCodeStorageService: verificationCodeStorageService,
        emailRepository: emailRepository,
        userAppSettingsRepository: userAppSettingsRepository,
        userContentPreferencesRepository: userContentPreferencesRepository,
        uuidGenerator: const Uuid(),
      );
      final dashboardSummaryService = DashboardSummaryService(
        headlineRepository: headlineRepository,
        categoryRepository: categoryRepository,
        sourceRepository: sourceRepository,
      );
      const permissionService = PermissionService();
      final UserPreferenceLimitService userPreferenceLimitService =
          DefaultUserPreferenceLimitService(
        appConfigRepository: appConfigRepository,
      );

      // 5. Provide all dependencies to the inner handler.
      return handler
          .use(provider<Uuid>((_) => const Uuid()))
          .use(provider<HtDataRepository<Headline>>((_) => headlineRepository))
          .use(provider<HtDataRepository<Category>>((_) => categoryRepository))
          .use(provider<HtDataRepository<Source>>((_) => sourceRepository))
          .use(provider<HtDataRepository<Country>>((_) => countryRepository))
          .use(provider<HtDataRepository<User>>((_) => userRepository))
          .use(provider<HtDataRepository<UserAppSettings>>(
              (_) => userAppSettingsRepository))
          .use(provider<HtDataRepository<UserContentPreferences>>(
              (_) => userContentPreferencesRepository))
          .use(provider<HtDataRepository<AppConfig>>((_) => appConfigRepository))
          .use(provider<HtEmailRepository>((_) => emailRepository))
          .use(provider<TokenBlacklistService>((_) => tokenBlacklistService))
          .use(provider<AuthTokenService>((_) => authTokenService))
          .use(provider<VerificationCodeStorageService>(
              (_) => verificationCodeStorageService))
          .use(provider<AuthService>((_) => authService))
          .use(provider<DashboardSummaryService>((_) => dashboardSummaryService))
          .use(provider<PermissionService>((_) => permissionService))
          .use(provider<UserPreferenceLimitService>(
              (_) => userPreferenceLimitService))
          .call(context);
    };
  });
}

