// routes/_middleware.dart
//
// ignore_for_file: avoid_slow_async_io, avoid_catches_without_on_clauses

import 'dart:convert';
import 'dart:io';

import 'package:dart_frog/dart_frog.dart';
import 'package:ht_api/src/middlewares/authentication_middleware.dart';
import 'package:ht_api/src/middlewares/error_handler.dart';
import 'package:ht_api/src/registry/model_registry.dart';
import 'package:ht_api/src/services/auth_service.dart';
import 'package:ht_api/src/services/auth_token_service.dart';
// Import the JWT service and blacklist service
import 'package:ht_api/src/services/jwt_auth_token_service.dart';
import 'package:ht_api/src/services/token_blacklist_service.dart';
import 'package:ht_api/src/services/verification_code_storage_service.dart';
import 'package:ht_app_settings_inmemory/ht_app_settings_inmemory.dart';
import 'package:ht_app_settings_repository/ht_app_settings_repository.dart';
import 'package:ht_data_inmemory/ht_data_inmemory.dart';
import 'package:ht_data_repository/ht_data_repository.dart';
import 'package:ht_email_inmemory/ht_email_inmemory.dart';
import 'package:ht_email_repository/ht_email_repository.dart';
import 'package:ht_shared/ht_shared.dart';
import 'package:uuid/uuid.dart'; // Import the uuid package

// --- Request ID Wrapper ---

/// {@template request_id}
/// A wrapper class holding a unique identifier (UUID v4) generated for each
/// incoming HTTP request.
///
/// **Purpose:**
/// The primary role of this ID is **traceability for logging and debugging**.
/// It allows developers to follow the entire lifecycle of a *single request*
/// through various middleware, route handlers, repository calls, and potential
/// external service interactions by searching logs for this specific ID.
/// If an error occurs during a request, this ID provides a way to isolate all
/// related log entries for that specific transaction, simplifying debugging.
///
/// **Scope:**
/// - The ID is **transient** for the request itself; it exists only during the
///   request-response cycle.
/// - It is **not persisted** in the main application database alongside models
///   like Headlines or Categories.
/// - Its value lies in being included in **persistent logs**.
///
/// **Distinction from other IDs:**
/// - **User ID:** Identifies the authenticated user making the request. Often
///   logged alongside the `request_id` for user-specific debugging.
/// - **Session ID:** Tracks a user's session across multiple requests.
/// - **Correlation ID:** Often generated by the *client* and passed in headers
///   to link related requests initiated by the client for a larger workflow.
///
/// **Implementation:**
/// This class ensures type safety when providing and reading the request ID
/// from the Dart Frog context using `context.provide<RequestId>` and
/// `context.read<RequestId>()`. This prevents potential ambiguity if other raw
/// strings were provided into the context.
/// {@endtemplate}
class RequestId {
  /// {@macro request_id}
  const RequestId(this.id);

  /// The unique identifier string (UUID v4).
  final String id;
}

// --- Helper Function to Load Fixtures ---
// Note:
// Error handling here is basic. In a real app,
// consider more robust file checks.
// ignore: unused_element
Future<List<Map<String, dynamic>>> _loadFixture(String fileName) async {
  final path = 'lib/src/fixtures/$fileName';
  try {
    final file = File(path);
    if (!await file.exists()) {
      print('Warning: Fixture file not found at $path. Returning empty list.');
      return [];
    }
    final content = await file.readAsString();
    final decoded = jsonDecode(content) as List<dynamic>?; // Allow null
    // Ensure items are maps
    return decoded?.whereType<Map<String, dynamic>>().toList() ?? [];
  } catch (e) {
    print('Error loading or parsing fixture file $path: $e');
    return []; // Return empty on error to avoid crashing startup
  }
}

// --- Repository Creation Logic ---
// Synchronous fixture loader (use with caution)
List<Map<String, dynamic>> _loadFixtureSync(String fileName) {
  final path = 'lib/src/fixtures/$fileName';
  try {
    final file = File(path);
    if (!file.existsSync()) {
      print('Warning: Fixture file not found at $path. Returning empty list.');
      return [];
    }
    final content = file.readAsStringSync();
    final decoded = jsonDecode(content) as List<dynamic>?;
    return decoded?.whereType<Map<String, dynamic>>().toList() ?? [];
  } catch (e) {
    print('Error loading or parsing fixture file $path: $e');
    return [];
  }
}

HtDataRepository<Headline> _createHeadlineRepository() {
  print('Initializing Headline Repository...');
  final initialData =
      _loadFixtureSync('headlines.json').map(Headline.fromJson).toList();
  final client = HtDataInMemoryClient<Headline>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Headline Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Headline>(dataClient: client);
}

HtDataRepository<Category> _createCategoryRepository() {
  print('Initializing Category Repository...');
  final initialData =
      _loadFixtureSync('categories.json').map(Category.fromJson).toList();
  final client = HtDataInMemoryClient<Category>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Category Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Category>(dataClient: client);
}

HtDataRepository<Source> _createSourceRepository() {
  print('Initializing Source Repository...');
  final initialData =
      _loadFixtureSync('sources.json').map(Source.fromJson).toList();
  final client = HtDataInMemoryClient<Source>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Source Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Source>(dataClient: client);
}

HtDataRepository<Country> _createCountryRepository() {
  print('Initializing Country Repository...');
  final initialData =
      _loadFixtureSync('countries.json').map(Country.fromJson).toList();
  final client = HtDataInMemoryClient<Country>(
    toJson: (i) => i.toJson(),
    getId: (i) => i.id,
    initialData: initialData,
  );
  print('Country Repository Initialized with ${initialData.length} items.');
  return HtDataRepository<Country>(dataClient: client);
}

// --- Middleware Definition ---
Handler middleware(Handler handler) {
  // Initialize repositories when middleware is first created
  // This ensures they are singletons for the server instance.
  final headlineRepository = _createHeadlineRepository();
  final categoryRepository = _createCategoryRepository();
  final sourceRepository = _createSourceRepository();
  final countryRepository = _createCountryRepository();
  final settingsClient = HtAppSettingsInMemory(); // Using in-memory for now
  final settingsRepository = HtAppSettingsRepository(client: settingsClient);
  const uuid = Uuid();

  // --- Auth Dependencies ---
  // User Repo (using InMemory for now)
  final userRepository = HtDataRepository<User>(
    dataClient: HtDataInMemoryClient<User>(
      toJson: (u) => u.toJson(),
      getId: (u) => u.id,
      // No initial user data fixture needed for auth flow typically
    ),
  );
  print('[MiddlewareSetup] HtDataRepository<User> instantiated.'); // Added log
  // Email Repo (using InMemory)
  const emailRepository = HtEmailRepository(
    emailClient: HtEmailInMemoryClient(),
  );
  print('[MiddlewareSetup] HtEmailRepository instantiated.'); // Added log
  // Auth Services (using JWT and in-memory implementations)
  final tokenBlacklistService = InMemoryTokenBlacklistService();
  print('[MiddlewareSetup] InMemoryTokenBlacklistService instantiated.');
  // Instantiate the JWT service, passing its dependencies
  final authTokenService = JwtAuthTokenService(
    userRepository: userRepository,
    blacklistService: tokenBlacklistService, // Pass the blacklist service
    uuidGenerator: uuid,
  );
  print('[MiddlewareSetup] JwtAuthTokenService instantiated.');
  final verificationCodeStorageService =
      InMemoryVerificationCodeStorageService();
  print(
    '[MiddlewareSetup] InMemoryVerificationCodeStorageService instantiated.',
  );
  final authService = AuthService(
    userRepository: userRepository,
    authTokenService: authTokenService,
    verificationCodeStorageService: verificationCodeStorageService,
    emailRepository: emailRepository,
    uuidGenerator: uuid,
  );
  print('[MiddlewareSetup] AuthService instantiated.'); // Added log

  // ==========================================================================
  //                            MIDDLEWARE CHAIN
  // ==========================================================================
  // IMPORTANT: The order of middleware matters significantly!
  // Middleware is applied in layers (like an onion). A request flows "in"
  // through the chain, hits the route handler, and the response flows "out".
  // Providers must be added *before* the middleware/handlers that read them.
  // Error handlers should typically be placed late in the "request" phase
  // (or early in the "response" phase) to catch errors from upstream.
  // ==========================================================================
  return handler
      // --- 1. Request ID Provider (Early Setup) ---
      // PURPOSE: Generates a unique ID (UUID v4) for each incoming request.
      //          Provides `RequestId` instance via context.
      // ORDER:   Placed *very early* so the ID is available for logging and
      //          tracing throughout the entire request lifecycle in all
      //          subsequent middleware and handlers.
      .use((innerHandler) {
        return (context) {
          final requestIdValue = uuid.v4();
          final requestId = RequestId(requestIdValue);
          // Provide the RequestId instance to downstream handlers/middleware
          return innerHandler(context.provide<RequestId>(() => requestId));
        };
      })

      // --- 2. Model Registry Provider (Early Setup) ---
      // PURPOSE: Provides the `ModelRegistry` map for dynamic JSON
      //          serialization/deserialization lookups.
      // ORDER:   Needed by some repository clients or handlers dealing with
      //          generic data types. Placed early, after RequestId.
      .use(modelRegistryProvider)

      // --- 3. Repository Providers (Core Data Access) ---
      // PURPOSE: Provide singleton instances of all data repositories.
      // ORDER:   These MUST be provided BEFORE any middleware or route handlers
      //          that need to interact with data (e.g., AuthService,
      //          authenticationProvider indirectly via AuthService/TokenService,
      //          specific route logic).
      .use(provider<HtDataRepository<Headline>>((_) => headlineRepository))
      .use(provider<HtDataRepository<Category>>((_) => categoryRepository))
      .use(provider<HtDataRepository<Source>>((_) => sourceRepository))
      .use(provider<HtDataRepository<Country>>((_) => countryRepository))
      .use(
        provider<HtDataRepository<User>>(
          (_) => userRepository,
        ),
      ) // Used by Auth services
      .use(provider<HtAppSettingsRepository>((_) => settingsRepository))
      .use(
        provider<HtEmailRepository>(
          (_) => emailRepository,
        ),
      ) // Used by AuthService

      // --- 4. Authentication Service Providers (Auth Logic Dependencies) ---
      // PURPOSE: Provide the core services needed for authentication logic.
      // ORDER:   These MUST be provided BEFORE `authenticationProvider` and
      //          any route handlers that perform authentication/authorization.
      //          - `Uuid` is used by `AuthService` and `JwtAuthTokenService`.
      //          - `AuthTokenService` is read by `authenticationProvider`.
      //          - `AuthService` uses several repositories and `AuthTokenService`.
      //          - `VerificationCodeStorageService` is used by `AuthService`.
      //          - `TokenBlacklistService` is used by `JwtAuthTokenService`.
      .use(provider<Uuid>((_) => uuid)) // Read by AuthService & TokenService
      .use(
        provider<TokenBlacklistService>(
          (_) => tokenBlacklistService,
        ),
      ) // Read by AuthTokenService
      .use(
        provider<AuthTokenService>(
          (_) => authTokenService,
        ),
      ) // Read by AuthService
      .use(
        provider<VerificationCodeStorageService>(
          (_) => verificationCodeStorageService,
        ),
      ) // Read by AuthService
      .use(
        provider<AuthService>(
          (_) => authService,
        ),
      ) // Reads other services/repos

      // --- 5. Request Logger (Logging) ---
      // PURPOSE: Logs details about the incoming request and outgoing response.
      // ORDER:   Often placed late in the request phase / early in the response
      //          phase. Placing it here logs the request *before* the handler
      //          runs and the response *after* the handler (and error handler)
      //          completes. Can access `RequestId` and potentially `User?`.
      .use(requestLogger())

      // --- 7. Error Handler (Catch-All) ---
      // PURPOSE: Catches exceptions thrown by upstream middleware or route
      //          handlers and converts them into standardized JSON error responses.
      // ORDER:   MUST be placed *late* in the chain (typically last before the
      //          actual handler is invoked by the framework, or first in the
      //          response processing flow) so it can catch errors from
      //          everything that came before it (providers, auth middleware,
      //          route handlers). If placed too early, it won't catch errors
      //          from middleware/handlers defined after it.
      .use(errorHandler());
}
